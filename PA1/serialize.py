import os
import sys

# IMPORTANT !
# this is needed to tell python where to find the flatbuffers package
# make sure to change this path to where you have compiled and installed
# flatbuffers.  If the python package is installed in your system wide files
# or virtualenv, then this may not be needed

sys.path.append(os.path.join (os.path.dirname(__file__), '/home/jovianw/Apps/flatbuffers/python')) # UPDATE THIS TO YOUR OWN DIRECTORY!
import flatbuffers    # this is the flatbuffers package we import

import time   # we need this get current time
import numpy as np  # to use in our vector field

import zmq   # we need this for additional constraints provided by the zmq serialization

import message as cm # our custom message in native format

# Generated by Flatbuf
import PA.Message as pamsg
import PA.MessageType as pamsgtype
import PA.Contents as pacontents
import PA.ResponseContents as parcontents
import PA.Code as pacode


# This is the method we will invoke from our driver program
# Note that if you have have multiple different message types, we could have
# separate such serialize/deserialize methods, or a single method can check what
# type of message it is and accordingly take actions.
def serialize (msg):
    
    # first obtain the builder object that is used to create an in-memory representation
    # of the serialized object from the custom message
    builder = flatbuffers.Builder(0)

    # Serialize message contents
    contents = []
    if msg.type == cm.MessageType.RESPONSE: # If responsecontents
      contents_field = builder.CreateString (msg.contents.contents) # contents is string
      # Serialize response contents
      parcontents.Start (builder)
      parcontents.AddCode (builder, msg.contents.code)
      parcontents.AddContents (builder, contents_field)
      contents.append (parcontents.End (builder))
    
    # Serialize message
    pamsg.Start (builder)  # serialization starts with the "Start" method
    pamsg.AddType (builder, msg.type)
    pamsg.AddContents (builder, contents[0])
    serialized_msg = pamsg.End (builder)  # get the topic of all these fields

    # end the serialization process
    builder.Finish (serialized_msg)

    # get the serialized buffer
    buf = builder.Output ()

    # return this serialized buffer to the caller
    return buf

# serialize the custom message to iterable frame objects needed by zmq
def serialize_to_frames (msg):
  """ serialize into an interable format """
  # We had to do it this way because the send_serialized method of zmq under the hood
  # relies on send_multipart, which needs a list or sequence of frames. The easiest way
  # to get an iterable out of the serialized buffer is to enclose it inside []
  return [serialize (msg)]
  
  
# deserialize the incoming serialized structure into native data type
def deserialize (buf):
    # Native format
    msg = cm.Message ()
    
    # Flatbuf formatted message from serialized buffer
    deser_msg = pamsg.Message.GetRootAs (buf, 0)

    # Message type
    msg.type = deser_msg.Type ()

    print("Contents are:", deser_msg.Contents ())

    # # Message contents
    # if deser_msg.Type () == pamsgtype.MessageType.RESPONSE:
    #    # Response message contents
    #    deser_msg.Contents

    # # name received
    # msg.contents = packet.Contents ()

    return msg
    
# deserialize from frames
def deserialize_from_frames (recvd_seq):
  """ This is invoked on list of frames by zmq """

  # For this sample code, since we send only one frame, hopefully what
  # comes out is also a single frame. If not some additional complexity will
  # need to be added.
  assert (len (recvd_seq) == 1)
  #print ("type of each elem of received seq is {}".format (type (recvd_seq[i])))
  # print ("received data over the wire = {}".format (recvd_seq[0]))
  cm = deserialize (recvd_seq[0])  # hand it to our deserialize method

  # assuming only one frame in the received sequence, we just send this deserialized
  # custom message
  return cm
    
